Problem 1)
	a. README.md is Unmodified, nothing to commit and branch is up to date
	b. README.md is Modified and fun_problem.txt is Untracked, both files not staged for commit and branch is up to date
	c. README.md and fun_problem.txt are both staged to be committed and branch is up to date
	d. README.md and fun_problem.txt are both Modified but not staged for commit, branch is ahead of master by 1 commit
	e. README.md is staged to be committed and fun_problem.txt is Unmodified, branch is ahead of master by 1 commit, fun_problem.txt is empty now since git checkout copied the repository version of the file (which was blank) over the local version
	f. README.md is both Modified, but not staged to be committed, and staged to be committed. The version of README that's staged to be committed doesn't have the phrase "Fancy git move" since it is the version that was added to be staged in the previous operation, and the version of README that is not committed but Modified represents this updated README.

Problem 2)
	a. Must start with a TAB, immediately following the dependency line
	b. Make clean will call rm which removes the files for all those in the current directory that ends in .o and specifically looks for the .o files called by shape1 and shape 2 and then exit the directory. Make shape1 will call g++ -o shape1 shape1.o shape.o -I$(IDIR) -std=c++11 -ggdb -lm
	c. It prevent the makefile from getting confused with executing certain actions if that name is also a file in your directory by disassociating the selected rules from files. For example, if you have a clean file then without .PHONY, the makefile won't know which clean to make.
	d. Makefile, makefile

Problem 3)
	1. A list of colleges (strings) who won NCAA championships in the order by year. A list would be preferred since the ADT is naturally ordered and allows quick access by index (year), and allows repition so multiple wins by the same college will be accepted.
	2. A set of ints of all available SSN's that have registered to vote would be preferred. A set not only prevents repition by nature, but also will offer efficient look up since a set looks up by value.
	3. A map of states as the key (strings) associated with a set of zip codes as the value (ints). This ADT would be preferred because zip codes are unique to their state but also don't repeat so storing them in a set and then assigning that set to a corresponding state would be ideal. Additionally, since maps offer quick lookup by value and since the set, as the value of the map, also offers quick lookup, it would be efficient finding if a zip exists.
	4. A map of users as the key with their unique IP as the key (int) and a list of URL's (strings). A map would be easiest if users were represented by a unique identifier, like the IP address, since it offers quick lookup of the URL list. A list as the value is also preferred since it allows for the repeated values to exist in that list and provides an index  for past visited URLS.
	5. A 2D array would be best


